# یادداشت‌های جامع: طراحی کلاس‌های خوب و پیشگیری از God Class
## صفحات ۱۰ تا ۱۳ اسلاید Sharif OOD Lecture 16 + تعمیق و الگوهای عملی

---

## پیام اصلی
از صفحات ۱۰ تا ۱۳ این اسلاید، پیام اصلی این است که «کلاس طراحی خوب» باید یک قرارداد شفاف با کلاینت‌ها داشته باشد و هم‌زمان **کافی**، **کامل** و **ابتدایی/اتمی** باشد، و همچنین «انسجام بالا» و «کوپلینگ پایین» را حفظ کند؛ و برای ارث‌بری هم هشدار می‌دهد که فقط وقتی واقعاً رابطه‌ی is‑a داریم سراغش برویم چون ارث‌بری قوی‌ترین نوع کوپلینگ است و انعطاف را کم می‌کند.

---

## بخش اول: قرارداد عمومی کلاس (Public Contract)

### تعریف
در صفحه ۱۰ گفته می‌شود عملیات public یک کلاس «قرارداد» آن کلاس با استفاده‌کننده‌هاست؛ یعنی اگر کلاس شما `Order` است، کل سیستم باید بتواند روی رفتارهای public آن حساب کند، بدون اینکه لازم باشد از جزئیات داخلی سر دربیاورد.

### معنای عمیق‌تر
این «قرارداد» یعنی: شما متعهد می‌شوید که این سرویس‌ها همیشه درست کار کنند، پیش‌شرط‌ها/پس‌شرط‌ها رعایت شوند، خطاها قابل پیش‌بینی باشند، و تغییرات داخلی تا جای ممکن کلاینت‌ها را نشکند.

از نگاه طراحی، هر متد public در واقع یک **تعهد بلندمدت** است: هر چی بیشتر و شلخته‌تر public بدهید، سطح تماس (Surface Area) سیستم بزرگ‌تر می‌شود و هزینه‌ی تغییر بالا می‌رود، چون هر تغییر ممکن است به تعداد زیادی مصرف‌کننده (Client) ضربه بزند.

### اجزای قرارداد
قرارداد صرفاً امضای متد نیست؛ شامل این‌ها هم می‌شود:
- **معنی دقیق رفتار:** مثلاً `cancel()` دقیقاً چه حالتی از سفارش را لغو می‌کند و در چه حالتی خطا می‌دهد
- **قواعد دامنه:** مثلاً «سفارش ارسال‌شده دیگر قابل لغو نیست»
- **استثناها/خطاها:** چه زمانی خطا بدهد، چه زمانی نتیجه‌ی خنثی برگرداند
- **اثرات جانبی:** بعد از `pay()` وضعیت دقیقاً چه می‌شود و آیا state تغییر پیدا می‌کند

### مثال عملی
```java
// ❌ قرارداد شلخته:
class Order {
    public void process() { /* ??? */ }
}
// → کلاینت‌ها نمی‌دانند processکنندگی چیست و state چی می‌شود

// ✅ قرارداد صحیح:
class Order {
    /**
     * امضا: برای پرداخت سفارش
     * شرط: سفارش باید PENDING باشد
     * نتیجه: state تبدیل به PAID می‌شود
     * استثنا: InvalidOrderException اگر DELIVERED یا CANCELLED
     * آثار: inventoryService.reserve() صدا زده می‌شود
     */
    public void pay(PaymentGateway gateway) throws InvalidOrderException {
        if (this.status != OrderStatus.PENDING) {
            throw new InvalidOrderException("Order is not pending");
        }
        // ...
    }
}
```

---

## بخش دوم: سه معیار کلیدی (Completeness / Sufficiency / Primitiveness)

طبق صفحه ۱۰، یک کلاس از نظر «خوب‌ساخت بودن» باید سه ویژگی داشته باشد:

### 1. Completeness (کامل‌بودن)
کلاس **«کمتر از چیزی که کلاینت منطقی انتظار دارد»** ارائه ندهد.

**مثال:** اگر کلاس `ShoppingCart` دارید، منطقی است که عملیات‌های `addItem/removeItem/getTotal` را داشته باشد؛ اگر `removeItem` را ندارید، کلاینت‌ها مجبور می‌شوند از بیرون با هک‌کاری لیست داخلی را دستکاری کنند یا کدهای تکراری بنویسند.

**عمق مسئله:**
ناقص بودن باعث می‌شود «منطق دامنه» (Domain Logic) از جای درستش (داخل کلاس) بیرون بریزد و در چندین کلاس پخش شود؛ یعنی:
- تکرار کد بیشتر می‌شود
- ناسازگاری رفتاری (مثل ۳ نسخه‌ی مختلف از «حذف آیتم»)
- باگ‌های عجیب (چون هر مصرف‌کننده یک برداشت متفاوت دارد)

**مثال اضافی:**
```java
// ❌ ناقص:
class Payment {
    public boolean charge(double amount) { 
        // پیاده‌سازی
        return true;
    }
    // اما refund متد ندارد!
}
// → بقیه کدها مجبور‌اند خود اعتبار را برگردانند (نادرست)

// ✅ کامل:
class Payment {
    public boolean charge(double amount) { 
        // پیاده‌سازی
        return true;
    }
    
    public boolean refund(double amount) { 
        // پیاده‌سازی
        return true;
    }
    
    public PaymentStatus status() { 
        // پیاده‌سازی
        return new PaymentStatus();
    }
}
```

### 2. Sufficiency (کافی/به‌قدر لازم بودن)
کلاس **«بیشتر از چیزی که کلاینت منطقی انتظار دارد»** ارائه ندهد.

**مثال:** اگر `User` علاوه بر رفتارهای مربوط به کاربر، متدهای `generateMonthlyRevenueReport()` یا `backupDatabase()` هم داشته باشد، این یعنی Interface کلاس را بی‌دلیل چاق کرده‌اید و هر تغییری در گزارش‌گیری/دیتابیس ممکن است کاربر را هم تحت تأثیر قرار دهد (ریسک شکستن قرارداد).

**نتیجه‌ی کافی نبودن این اصل (زیاده‌روی):**
کلاس تبدیل می‌شود به «انبار قابلیت‌ها» و بعد کم‌کم همه چیز به آن وابسته می‌شود؛ دقیقاً همان مسیری که تهش **God Class** در می‌آید.

**مثال اضافی:**
```java
// ❌ زیاده‌روی:
class UserService {
    public void createUser(UserData data) { }
    
    public void generateRevenueReport() { }  // آه؟
    
    public void backupDatabase() { }  // این چرا اینجاست؟
    
    public void sendNewsletterCampaign() { }  // یا این؟
    
    public void configureEmailServer() { }  // یا این؟!!
}
// → اگر گزارش‌گیری مسائل پیدا کرد، User Service شکست می‌خوره

// ✅ کافی:
class UserService {
    public void createUser(UserData data) { 
        // پیاده‌سازی
    }
    
    public void updateUser(UUID id, UserData data) { 
        // پیاده‌سازی
    }
    
    public void deleteUser(UUID id) { 
        // پیاده‌سازی
    }
}
// رویدادهای دامنه بفرستاد (UserCreated, UserDeleted)
// بقیه خودشون گوش می‌دهند
```

### 3. Primitiveness (ابتدایی/اتمی بودن سرویس‌ها)
سرویس‌ها باید **ساده، اتمی و یکتا** باشند.

یعنی متدها **«کار بزرگِ چندمرحله‌ایِ مبهم»** انجام ندهند.

**مثال:** متدی مثل `processOrder()` که:
- هم پرداخت را انجام می‌دهد
- هم ایمیل می‌فرستد
- هم انبار را آپدیت می‌کند
- هم لاگ و ریتری می‌زند

معمولاً اتمی نیست و تست/دیباگ را سخت می‌کند؛ بهتر است این کار به چند مسئولیت کوچک شکسته شود و orchestration در سطح بالاتر انجام شود.

**عمق ماجرا:**
وقتی سرویس اتمی نیست، شما نمی‌توانید مرز خطاها را درست مدیریت کنید:
- اگر پرداخت موفق شد ولی ایمیل ارسال نشد، سیستم در چه وضعیتی است؟
- آیا باید refund کنیم؟
- آیا order را واقعاً processing کردیم یا نه؟

همین موضوع سیستم را به سمت **Accidental Complexity** (پیچیدگی تصادفی) هل می‌دهد.

**مثال اضافی:**
```java
// ❌ non-atomic:
class OrderService {
    public void processOrder(Order order) {
        // پرداخت
        paymentService.charge(order.amount);
        
        // آپدیت انبار
        inventoryService.reserve(order.items);
        
        // ارسال ایمیل
        emailService.sendOrderConfirmation(order.customerId);
        
        // بروز کردن state
        orderRepository.save(order);
    }
}
// → اگر emailService بیفتد، order.state آپدیت شده است (ناسازگاری!)

// ✅ atomic:
class OrderService {
    public OrderProcessResult processOrder(Order order) {
        PaymentResult payment = paymentService.charge(order.amount);
        if (!payment.isSuccessful()) {
            throw new PaymentFailedException();
        }
        
        ReservationResult reservation = inventoryService.reserve(order.items);
        if (!reservation.isSuccessful()) {
            paymentService.refund(order.amount);
            throw new OutOfStockException();
        }
        
        order.markAsPaid();
        return new OrderProcessResult(order.id, payment.transactionId);
    }
    
    // در جایی دیگر (Event Listener):
    // @EventListener
    public void onOrderProcessed(OrderProcessResult result) {
        emailService.sendConfirmation(result.orderId);
    }
}
```

### خلاصه این سه معیار
این سه‌تا دقیقاً **ریشه‌ی بحث «چرا ساده نگه داریم»** است: کلاس خوب نه کم می‌گذارد، نه زیادی می‌کند، نه کارهای مبهم و درشت انجام می‌دهد.

---

## بخش سوم: سادگی و "بیشینه‌کردن کارهایی که نباید انجام دهیم"

تعریف («بیشینه کردن کارهایی که نباید انجام داد») دقیقاً در راستای یک نگاه مهندسی به سادگی است: **سادگی یعنی عمداً از پیچیدگی‌های غیرضروری، انتزاع‌های زودهنگام، و فیچرهایی که هنوز نیاز نیستند دوری کنیم** تا سیستم قابل فهم و قابل تغییر بماند.

این دقیقاً هم‌جهت با **KISS** (Keep It Simple, Stupid) است که می‌گوید طراحی‌ها وقتی بهتر عمل می‌کنند که تا حد ممکن ساده نگه داشته شوند و از پیچیده‌سازی بی‌دلیل اجتناب شود.

### انواع "کارهایی که نباید انجام دهیم"

#### 1. عمومی‌سازی زودهنگام (Premature Generalization)
وقتی یک نیاز هنوز قطعی نیست، **عمومی‌سازی زودهنگام** معمولاً همان «کاری است که نباید انجام داد» چون قبل از داشتن شواهد واقعی، دارید سیستم را برای آینده‌ی خیالی پیچیده می‌کنید.

**مثال:**
```java
// ❌ زیاده‌روی:
// هنوز یک integration پرداخت نداریم
// اما ما 5 الگوی مختلف payment gateway پیش‌فرض می‌سازیم
class PaymentGateway {
    PaymentProcessor getProcessor(String strategy) {
        if (strategy.equals("STRIPE")) 
            return new StripeProcessor();
        if (strategy.equals("PAYPAL")) 
            return new PayPalProcessor();
        if (strategy.equals("SQUARE")) 
            return new SquareProcessor();
        if (strategy.equals("2CHECKOUT")) 
            return new TwoCheckoutProcessor();
        if (strategy.equals("AUTHORIZE")) 
            return new AuthorizeProcessor();
        return null;
    }
}
// → اضافی انتزاع، کد نباخته، کسی هنوز نیاز نکرده

// ✅ درست:
// فقط Stripe رو معرفی کن
class StripePaymentService {
    public PaymentResult charge(double amount) { 
        // پیاده‌سازی
        return new PaymentResult();
    }
}
// وقتی PayPal حقیقی شد، بعداً generalize کن
```

#### 2. راه حل پیچیده وقتی ساده‌تر کفاف دهد
وقتی می‌توان با یک راه‌حل ساده‌تر همان ارزش را داد، انتخاب راه پیچیده‌تر بدون دلیل، **خلاف KISS** است (هزینه‌ی یادگیری، تست، دیباگ و تغییر را بالا می‌برد).

**مثال:**
```java
// ❌ بیش‌پیچیده:
// Event-driven architecture برای یه log کردن ساده
class UserCreatedEvent extends DomainEvent { }
class EventBus { /* publish/subscribe */ }
class UserCreationEventHandler implements EventListener { }
interface EventListener { void handle(DomainEvent event); }

// ❌ بیش‌مهندسی:
// CQRS برای یه سرویس ساده‌ی user CRUD
class UserCommand { }
class UserQuery { }
class UserCommandHandler { }
class UserQueryHandler { }

// ✅ ساده:
// هر کاری با کلاس معمولی
class UserService {
    public User create(UserData data) {
        User user = new User(data);
        repository.save(user);
        return user;
    }
}
```

#### 3. Abstraction فقط برای "قشنگی معماری"
وقتی abstraction جدید فقط برای "قشنگ شدن معماری" ساخته می‌شود نه برای حل یک درد واقعی، غالباً اضافه‌کاری است و بعداً هم تبدیل به سربار ذهنی تیم می‌شود.

**مثال:**
```java
// ❌ abstraction برای abstraction:
interface Repository<T> { }
interface Service<T> { }
interface Controller<T> { }
interface DTO<T> { }
// ... دو برابر کد، هیچ مسئله حل نشد

// ✅ انتزاع در جاش:
// فقط وقتی مختلف پیاده‌سازی دارم
interface PaymentRepository {
    void save(Payment p);
    Payment findById(UUID id);
}
// دو پیاده‌سازی: SQL Database, Redis Cache
class SqlPaymentRepository implements PaymentRepository { }
class RedisPaymentRepository implements PaymentRepository { }
```

---

## بخش چهارم: انسجام بالا و کوپلینگ پایین (صفحه ۱۱) - ریشه‌ی God Class

صفحه ۱۱ می‌گوید:

### High Cohesion (انسجام بالا)
هر کلاس باید **«یک مفهوم انتزاعی مشخص»** را نمایندگی کند و عملیاتش در خدمت همان intent باشد.

**معنی:** متدهای کلاس باید تمام‌اً دور یک مسئولیت واحد بچرخند؛ اگر `Order` کلاس است، تمام متدهاش درباره‌ی `Order` باشد (مثل `addItem`, `removeItem`, `calculateTotal`).

### Low Coupling (کوپلینگ پایین)
کلاس فقط **به اندازه‌ی لازم** به کلاس‌های دیگر وابسته باشد؛ فقط وقتی دو کلاس را وصل کن که **رابطه‌ی معنایی واقعی** دارند، و صرفاً برای reuse کردن چند خط کد، کوپلینگ ایجاد نکن.

**معنی:** هر کلاس باید تا حد ممکن مستقل باشد تا تغییر در یک کلاس، دیگران را تحت تأثیر قرار ندهد.

### اینجا جایی است که God Class متولد می‌شود
God Class دقیقاً نقطه‌ی مقابل این دو اصل است: کلاسی که:
- چندین مسئولیت **بی‌ربط** را در خودش جمع می‌کند
- پراپرتی‌های **نامرتبط** دارد
- تعداد زیادی متد بدون پیوند منطقی (جز اینکه «همه‌شان برای سیستم حیاتی‌اند») داخلش هست

### چه زمانی God Class رخ می‌دهد؟
وقتی انسجام پایین و کوپلینگ بالا رخ می‌دهد:
- تغییر کوچک در یک بخش باعث شکستن بخش‌های دیگر می‌شود
- تست سخت می‌شود (چون همه‌چیز درهم تنیده است)
- توسعه تیمی کند می‌شود (conflict های merge بیشتر می‌شود)
- بدهی فنی رشد می‌کند (چون همه از دست زدن به آن کلاس می‌ترسند)

### مثال واقعیِ "خدای کد" در پروژه‌های وب
```java
// ❌ God Class:
class ApplicationService {
    // Authentication & Authorization
    public User login(String username, String password) { }
    public void logout(UUID userId) { }
    public boolean hasPermission(UUID userId, String permission) { }
    
    // Database
    public Connection getConnection() { }
    public void runMigration() { }
    public void backupDatabase() { }
    
    // Email & SMS
    public void sendEmail(String to, String message) { }
    public void sendSMS(String phone, String message) { }
    
    // Payment
    public PaymentResult processPayment(Order order) { }
    public void refund(UUID paymentId) { }
    
    // Discount Rules
    public double applyDiscount(Order order) { }
    public List<Discount> getAvailableDiscounts() { }
    
    // Reporting
    public Report generateMonthlyReport() { }
    public Report generateUserAnalytics() { }
    
    // Cache
    public void clearCache(String key) { }
    public void invalidateAllCache() { }
}
```

این کلاس دقیقاً همان **anti-pattern** است چون:
- مرز مسئولیت‌ها و دامنه‌ها را نابود می‌کند
- کل سیستم را به **یک نقطه شکننده** تبدیل می‌کند

### چطور God Class رو تشخیص بدیم؟

**علائم هشداری:**
- **تعداد متد (۲۰+):** نشانه‌ی اینکه مسئولیت‌های زیادی داریم
- **تعداد پراپرتی (۱۵+):** state متنوع و نامرتبط
- **رشته‌های بلند:** مثل `if (user.isAdmin) { ... } else if (user.isModerator) { ... }` تو متدهای مختلف
- **نام‌های عمومی:** `Manager`, `Handler`, `Service` (بدون مشخص بودن کلاس چی می‌کند)
- **بلاک کامنت‌های توضیحی:** `// === USER MANAGEMENT === ... // === DATABASE === ... // === PAYMENT ===`
- **ترس از تغییر:** هر‌کسی از دست زدن به کلاس می‌ترسد

### refactor کردن God Class

**گام۱: شناخت مسئولیت‌ها**
```
ApplicationService شامل:
1. Authentication/Authorization → AuthenticationService
2. Database & Migration → DatabaseService
3. Email/SMS → NotificationService
4. Payment Processing → PaymentService
5. Discount Rules → DiscountingService
6. Reporting → ReportingService
7. Cache Management → CacheService
```

**گام۲: Extract کردن هر مسئولیت**
```java
// ✅ بعد از refactor:
class AuthenticationService {
    public User login(String username, String password) { 
        // پیاده‌سازی
    }
    
    public void logout(UUID userId) { 
        // پیاده‌سازی
    }
}

class NotificationService {
    public void sendEmail(String to, String message) { 
        // پیاده‌سازی
    }
    
    public void sendSMS(String phone, String message) { 
        // پیاده‌سازی
    }
}

class PaymentService {
    public PaymentResult process(Order order) { 
        // پیاده‌سازی
    }
    
    public void refund(UUID paymentId) { 
        // پیاده‌سازی
    }
}

// ... و غیره

// و اگر واقعاً یک جای مرکزی نیاز بود:
class ApplicationOrchestrator {
    private AuthenticationService auth;
    private PaymentService payment;
    private NotificationService notification;
    
    public void processNewUser(UserSignUpRequest req) {
        User user = auth.createUser(req);
        notification.sendWelcomeEmail(user.email);
    }
}
```

---

## بخش پنجم: الگوهای طراحی - "دارو" نه "ویتامین"

یکی از اشتباهات رایج این است که Design Pattern را مثل «چیز خوب مطلق» ببینیم و همه‌جا تزریق کنیم؛ اما **هدف الگوها کنترل پیچیدگی است، نه تولید پیچیدگی جدید**.

اگر الگو باعث شود:
- مدل ذهنی تیم سخت‌تر شود
- کد برای حل یک مسئله ساده "بیش‌مهندسی" شود

آن الگو در عمل **خلاف KISS** کار می‌کند، حتی اگر اسمش شیک باشد.

### کاربرد درست الگوها (۴ مثال واقعی)

#### الگو ۱: Strategy/Policy Pattern
**مسئله:** چند پیاده‌سازی مختلف از یک رفتار داریم و می‌خواهیم قابل تعویض باشند.

**مثال:**
```java
class Order {
    private ShippingStrategy shippingStrategy;
    
    public Order withShipping(ShippingStrategy strategy) {
        this.shippingStrategy = strategy;
        return this;
    }
    
    public double calculateShippingCost() {
        return shippingStrategy.calculateCost(this);
    }
}

interface ShippingStrategy {
    double calculateCost(Order order);
}

class StandardShipping implements ShippingStrategy {
    public double calculateCost(Order order) { 
        return 5.0; 
    }
}

class ExpressShipping implements ShippingStrategy {
    public double calculateCost(Order order) { 
        return 15.0; 
    }
}

class FreeShipping implements ShippingStrategy {
    public double calculateCost(Order order) { 
        return 0.0; 
    }
}

// استفاده:
Order order = new Order();
order.withShipping(new ExpressShipping());
// دیگر شب‌ها می‌شود تعویض کرد بدون تغییر Order class
```

**چرا مفید:** مسائل دنیای واقعی معمولاً چندین راه حل دارند (شیوه‌های مختلف shipping، pricing algorithms، validation rules)؛ Strategy این تنوع را مدیریت می‌کند بدون اینکه Order class به همه‌شان وابسته شود.

#### الگو ۲: Facade Pattern
**مسئله:** می‌خواهیم پیچیدگی یک زیرسیستم را پشت یک API ساده پنهان کنیم.

**مثال:**
```java
// ❌ بدون Facade (مصرف‌کننده باید همه رو بفهمه):
PaymentGateway gateway = new PaymentGateway();
ValidationService validator = new ValidationService();
AuditService auditor = new AuditService();
EmailService mailer = new EmailService();

validator.validate(paymentData);
auditor.logPaymentAttempt(userId, amount);
PaymentResult result = gateway.charge(amount);
mailer.sendConfirmation(userId, result);

// ✅ با Facade (ساده و واضح):
class PaymentFacade {
    private PaymentGateway gateway;
    private ValidationService validator;
    private AuditService auditor;
    private EmailService mailer;
    
    public PaymentResult processPayment(UUID userId, double amount) {
        validator.validate(amount);
        auditor.logPaymentAttempt(userId, amount);
        PaymentResult result = gateway.charge(amount);
        mailer.sendConfirmation(userId, result);
        return result;
    }
}

// استفاده:
paymentFacade.processPayment(userId, 100.0);
```

**نکته‌ی جالب:** حتی برای شکستن God Class گاهی توصیه می‌شود موقتاً God Class را به یک Facade تبدیل کنید که فقط delegate کند، تا مهاجرت تدریجی ممکن شود.

```java
// مرحله‌ی انتقالی:
class ApplicationServiceFacade {
    private AuthenticationService auth;
    private PaymentService payment;
    private NotificationService notification;
    
    // God Class تدریجی پنهان می‌شود پشت Facade
    public User login(String username, String password) {
        return auth.login(username, password);
    }
    
    public PaymentResult processPayment(Order order) {
        PaymentResult result = payment.process(order);
        notification.sendConfirmation(order.customerId);
        return result;
    }
}
```

#### الگو ۳: Dependency Injection / IoC Container
**مسئله:** کلاس‌ها به هم وابسته‌اند (`new` کردن) و تست کردن سخت می‌شود.

**مثال:**
```java
// ❌ بدون DI (بسیار تنگ coupled):
class OrderService {
    private PaymentService paymentService = new PaymentService();
    private InventoryService inventoryService = new InventoryService();
    // اگر PaymentService ساخت تغییر کرد، اینجا هم تغییر می‌کند
    
    public void processOrder(Order order) {
        paymentService.charge(order.amount);
        inventoryService.reserve(order.items);
    }
}

// ✅ با DI (loose coupled):
class OrderService {
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    
    public OrderService(PaymentService paymentService, 
                       InventoryService inventoryService) {
        this.paymentService = paymentService;
        this.inventoryService = inventoryService;
    }
    
    public void processOrder(Order order) {
        paymentService.charge(order.amount);
        inventoryService.reserve(order.items);
    }
}

// تست:
class OrderServiceTest {
    public void testProcessOrder() {
        PaymentService mockPayment = mock(PaymentService.class);
        InventoryService mockInventory = mock(InventoryService.class);
        
        OrderService service = new OrderService(mockPayment, mockInventory);
        // تست بدون وابستگی واقعی
    }
}
```

**اما:** اگر بی‌جا و افراطی استفاده شود، خودش پیچیدگی می‌آورد (Spring Container شناسایی کلاس‌ها، Circular Dependencies، و غیره).

#### الگو ۴: Observer Pattern (Event-Driven)
**مسئله:** کلاس‌ها برای اطلاع همدیگر، tight coupling می‌سازند.

**مثال:**
```java
// ❌ بدون Observer (tight coupling):
class UserService {
    private EmailService emailService;
    private ReportingService reportingService;
    private AnalyticsService analyticsService;
    
    public void createUser(UserData data) {
        User user = new User(data);
        repository.save(user);
        
        // همه جا تعریف شده، کلاس بزرگ می‌شود
        emailService.sendWelcomeEmail(user);
        reportingService.recordNewUser(user);
        analyticsService.trackUserSignup(user);
    }
}

// ✅ با Observer (loose coupling):
class UserService {
    private final EventPublisher eventPublisher;
    
    public void createUser(UserData data) {
        User user = new User(data);
        repository.save(user);
        eventPublisher.publish(new UserCreatedEvent(user));
    }
}

// هر کسی گوش می‌دهد:
class EmailNotificationListener {
    // @EventListener
    public void onUserCreated(UserCreatedEvent event) {
        emailService.sendWelcomeEmail(event.user);
    }
}

class ReportingListener {
    // @EventListener
    public void onUserCreated(UserCreatedEvent event) {
        reportingService.recordNewUser(event.user);
    }
}

class AnalyticsListener {
    // @EventListener
    public void onUserCreated(UserCreatedEvent event) {
        analyticsService.trackUserSignup(event.user);
    }
}
```

**فایده:** UserService هیچ‌کس را نمی‌شناسد؛ جدید listener اضافه کن، کار می‌کند.

---

## بخش ششم: ارث‌بری - فقط is‑a، نه is‑a‑role (صفحه ۱۲–۱۳)

صفحه ۱۲ می‌گوید ارث‌بری را **فقط وقتی استفاده کن** که واقعاً رابطه‌ی is‑a واضح باشد (یا برای reuse کد، با احتیاط)؛ چون ارث‌بری:
- **«قوی‌ترین کوپلینگ»** را ایجاد می‌کند
- **encapsulation** را درون سلسله‌مراتب ضعیف می‌کند
- انعطاف‌ناپذیر است (تصمیم در زمان کامپایل گرفته می‌شود)

صفحه ۱۳ اضافه می‌کند: زیرکلاس باید «is‑kind‑of» باشد نه «is‑role‑played‑by» و برای role بهتر است aggregation/composition استفاده شود.

### مثال: نقش vs نوع

**نوع (درست برای Inheritance):**
```java
// ✅ SavingsAccount is-a BankAccount
// → معنی: حساب پس‌انداز نوعی حساب بانکی است
// → ویژگی‌های مشترک: balance، owner، transactions
// → رفتار مختلف: savingsAccount.calculateInterest() != checkingAccount.calculateInterest()

class BankAccount {
    protected double balance;
    
    public void deposit(double amount) { 
        // پیاده‌سازی
    }
    
    public void withdraw(double amount) { 
        // پیاده‌سازی
    }
    
    abstract double calculateInterest();
}

class SavingsAccount extends BankAccount {
    private double interestRate = 0.05;
    
    @Override
    double calculateInterest() { 
        return balance * interestRate; 
    }
}

class CheckingAccount extends BankAccount {
    @Override
    double calculateInterest() { 
        return 0; // بدون سود
    }
}
```

**نقش (غلط برای Inheritance):**
```java
// ❌ User is-a Admin
// → مشکل: ادمین نقش است نه نوع
// → یک کاربر می‌تواند هم ادمین باشد و هم Moderator (دو نقش)
// → نقش‌ها در Runtime تغییر می‌کنند

// ❌ کلاس سازی نادرست:
class User { }
class Admin extends User { }
class Moderator extends User { }
// اما یک user می‌خواهد هم Admin باشد و هم Moderator؟ ممکن نیست!

// ✅ درست: Composition
class User {
    private Set<Role> roles = new HashSet<>();
    
    public void addRole(Role role) { 
        roles.add(role); 
    }
    
    public void removeRole(Role role) { 
        roles.remove(role); 
    }
    
    public boolean hasRole(Role role) { 
        return roles.contains(role); 
    }
}

interface Role {
    String getName();
    List<Permission> getPermissions();
}

class AdminRole implements Role {
    @Override
    public String getName() { 
        return "ADMIN"; 
    }
    
    @Override
    public List<Permission> getPermissions() {
        return Arrays.asList(
            Permission.DELETE_USER,
            Permission.MANAGE_ROLES,
            Permission.VIEW_ANALYTICS
        );
    }
}

class ModeratorRole implements Role {
    @Override
    public String getName() { 
        return "MODERATOR"; 
    }
    
    @Override
    public List<Permission> getPermissions() {
        return Arrays.asList(
            Permission.DELETE_COMMENT,
            Permission.SUSPEND_USER
        );
    }
}

// استفاده:
User user = new User();
user.addRole(new AdminRole());
user.addRole(new ModeratorRole());  // ✅ دو نقش!
```

### مشکلات Inheritance

```java
// ❌ مشکل ۱: Fragile Base Class Problem
class Animal {
    protected void move() { /* پیاده */ }
}

class Dog extends Animal {
    @Override
    public void move() { /* سگ بدل */ }
}

// بعداً Animal.move() تغییر می‌کند... Dog خراب می‌شود!

// ✅ بهتر: Composition
class Dog {
    private Movement movement = new DogMovement();
    
    public void move() { 
        movement.execute(); 
    }
}

interface Movement { 
    void execute(); 
}

class DogMovement implements Movement { 
    // پیاده‌سازی
}
```

```java
// ❌ مشکل ۲: The Gorilla-Banana Problem
class Primates { }
class Gorilla extends Primates { }  // هر gorilla باید banana را handle کند
class Chimpanzee extends Primates { }

// اگر نیاز به "رفتار gorilla برای banana" داشتیم، inheritance همه‌ی Primates رو درگیر کرد

// ✅ بهتر: Composition + Behavior
class Gorilla {
    private BananaHandler bananaHandler;
}
```

---

## خلاصه‌ی یک‌پارچه

| معیار | توضیح | مثال غلط | مثال درست |
|------|--------|---------|----------|
| **Completeness** | نه کمتر از انتظار | `ShoppingCart` بدون `removeItem()` | `removeItem()` وجود دارد |
| **Sufficiency** | نه بیشتر از نیاز | `User` با `backupDatabase()` | فقط `User` logic |
| **Primitiveness** | سرویس‌های اتمی | `processOrder()` همه کار می‌کند | چند متد کوچک |
| **High Cohesion** | یک مسئولیت | کلاس مختلط (Auth + DB + Email) | هر کلاس یک کار |
| **Low Coupling** | کم وابستگی | `new PaymentService()` درون | تزریق وابستگی |
| **KISS** | ساده نگه داریم | Premature generalization | فقط آنچه لازم است |
| **Inheritance** | فقط is-a | `User is-a Admin` | `User has-a Role` |

---

## چک‌لیست: آیا کلاس‌ام خوب‌ساخت است؟

قبل از کمیت کردن کد، بپرسید:

□ آیا کلاس یک مفهوم واحد را نمایندگی می‌کند؟
□ آیا تمام متدها این مفهوم را پشتیبانی می‌کنند؟
□ آیا نام کلاس واضح است و وعده (contract) کار را می‌دهد؟
□ آیا Public APIs کامل و کافی‌اند؟
□ آیا Public APIs اتمی هستند (Small, focused, atomic)?
□ آیا وابستگی‌های دیگری را نیاز دارم؟
□ اگر بله، آیا آن‌ها واقعاً ضروری‌اند؟
□ آیا Inheritance واقعاً معنی‌دار است یا Composition بهتر است؟
□ آیا می‌توانم این کلاس را در isolation test کنم؟
□ اگر نه، چرا؟ (وابستگی‌های نهفته)
□ آیا این کلاس برای 6 ماه دیگر قابل نگهداری است؟
□ آیا تیم‌مان این کلاس را می‌فهمد؟

اگر یکی هم "نه" شد → refactor کن

---

## منابع
- Sharif University OOD Lecture 16 (صفحات 10-13)
- KISS Principle (Wikipedia)
- KISS Principle in Software Development (GeeksforGeeks)
- How to Refactor God Object Anti-pattern (TheServerSide)